-- УРОК 5. «Операторы, фильтрация, сортировка и ограничение»
-- ---------Задание 1. ----------------------------------------
/*Пусть в таблице users поля created_at и updated_at оказались незаполненными. 
 * Заполните их текущими датой и временем.*/

select * from users; 

-- при создании эти колонки заполняются автоматически, поэтому используем обновить:
UPDATE users SET created_at = NOW();
UPDATE users SET updated_at = NOW();

-- проверяем
select * from users; 


-- ---------Задание 2. ----------------------------------------
/* Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR
 * и в них долгое время помещались значения в формате 20.10.2017 8:10. 
 * Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.*/

-- проверяем существующие настройки таблицы:
DESCRIBE users;

ALTER TABLE users CHANGE created_at created_at DATETIME DEFAULT CURRENT_TIMESTAMP;
ALTER TABLE users CHANGE updated_at updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;


-- ---------Задание 3. ----------------------------------------
/* В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, 
 если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, 
 чтобы они выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, 
 после всех записей.*/

-- таблица оказалась пуста. заполню произвольно
INSERT INTO storehouses_products VALUES
   (1, 1, 1, 20, NOW(), NOW()),
   (2, 1, 2, 0, NOW(), NOW()),
   (3, 1, 3, 250, NOW(), NOW()),
   (4, 1, 4, 65, NOW(), NOW());

-- сортируем таблицу по столбцу value
select * from storehouses_products  where value > 0 ORDER by value and where value = 0 ORDER by value desc; 

SELECT * from storehouses_products if(value > 0, ORDER by value , ORDER by value desc);





-- ---------Задание 4. ----------------------------------------
/*(по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. 
 Месяцы заданы в виде списка английских названий (may, august)*/

-- ---------Задание 5. ----------------------------------------
/*(по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. 
 SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.*/


-- ---------Задание 6.1 ----------------------------------------
/* Практическое задание к теме «Агрегация данных»
6.1 Подсчитайте средний возраст пользователей в таблице users.*/

-- выводим возраст пользователей:
select name, TIMESTAMPDIFF(YEAR, birthday_at, NOW()) AS age FROM users;

-- считаем средний возраст:
select AVG(TIMESTAMPDIFF(YEAR, birthday_at, NOW())) FROM users;

-- ---------Задание 6.2 ----------------------------------------
/* Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. 
 Следует учесть, что необходимы дни недели текущего года, а не года рождения.*/


-- изменим формат ДР 
SELECT name, DATE_FORMAT(birthday_at, '%d.%m.2022') AS birthday_at FROM users;

-- Выводим номер дня недели ( начиная с воскресенья -0) и считаем через группировку
SELECT name, birthday_at, DATE_FORMAT(birthday_at, '%d.%m.2022') as dr, weekday(DATE_FORMAT(birthday_at, '%d.%m.2022')) AS week1, COUNT(*) from users group by week1;


-- ---------Задание 6.3 ----------------------------------------
-- (по желанию) Подсчитайте произведение чисел в столбце таблицы.

